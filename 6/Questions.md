1. Состояние гонки <br /> 
Состояние гонки - это состояние многопоточной системы, при котором работа системы зависит от того, 
в каком порядке выполняются части кода. Допустим два потока обращаются к одной общей переменной и 
как-либо её модифицируют. Пусть по замыслу разработчика первый поток должен внести изменения в переменную, 
затем второй поток должен считать новое значение переменной и снова как-либо его модифицировать.
При состоянии гонки может случится так, что второй поток прочитает значение переменной раньше, чем 
первый поток успеет его модифицировать, что приведет к непредсказуемому результату <br />

2. Mutex'ы и условные переменные <br />
Mutex является примитивом синхронизации.
Примитивы синхронизации — механизмы, позволяющие реализовать взаимодействие потоков, например, 
единовременный доступ только одного потока к критической области.
Примитивы синхронизации преследуют различные задачи:
- Взаимное исключение потоков — примитивы синхронизации гарантируют то, что единовременно с критической областью будет работать только один поток.
- Синхронизация потоков — примитивы синхронизации помогают отслеживать наступление тех или иных конкретных событий, то есть поток не будет работать, пока не наступило какое-то событие. Другой поток в таком случае должен гарантировать наступление данного события. <br />
Условная переменная - примитив синхронизации, обеспечивающий блокирование одного или нескольких потоков до момента поступления сигнала от другого потока о выполнении некоторого условия или до истечения максимального промежутка времени ожидания. <br />

3. Гранулярность блокировок <br />
Под гранулярность понимается объем данных, защищаемых блокировкой. Гранулярность определяет, к 
каким данным доступ будет заблокирован, а также продолжительность блокировки. если несколько 
потоков ждут одного ресурса , то, удерживая блокировку дольше необходимого, они заставляют 
другие потоки проводить в очереди больше времени. Мьютекс должен захватываться непосредственно перед доступом к разделяемым 
данным; Обработка данных, находящихся под защитой мьютекса, по возможности не должна производится длительными операциями. 
Например файловый ввод/вывод, обычно выполняется в сотни раз медленнее чтения или записи того же объема данных в 
памяти. Поэтому если блокировка не нужна для защиты доступа к файлу, то удерживание блокировки 
заставляет другие потоки ждать без необходимости (так как они не могут захватить мьютекс), и тем 
самым можно свести на нет весь выигрыш от многопоточной работы. Если один мьютекс защищает структуру данных целиком, 
то не только возрастает конкуренция за него, но и шансов снизить время удержания остается меньше. Поскольку под 
защитой одного мьютекса приходится выполнять больше операций, то и удерживать его нужно дольше. Такая двойная угроза 
должна вдвое усилить стремление всюду, где возможно, использовать мелкогранулярные блокировки. <br />

4. Взаимная блокировка <br />
Взаимная блокировка - ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение. Классический способ борьбы с взаимными блокировками состоит в том, чтобы захватывать несколько мьютексов всегда в одинаковом порядке. 
Более строго, это значит, что между блокировками устанавливается отношение сравнения и вводится правило о запрете захвата «большей» блокировки в состоянии, когда уже захвачена «меньшая». Таким образом, если процессу нужно несколько блокировок, ему нужно всегда начинать с самой «большой» — предварительно освободив все захваченные «меньшие», если такие есть — и затем в нисходящем порядке. Это может привести к лишним действиям (если «меньшая» блокировка нужна и уже захвачена, она освобождается только чтобы тут же быть захваченной снова), зато гарантированно решает проблему. <br />

5. Атомарные операции <br />
Появление многопоточности, помимо прочего, вносит сложность с загрузкой и сохранением данных. Ведь далеко не любая структура данных может быть загружена\сохранена в память одной операцией. Более того, то, что может быть загружено\сохранено в память одной операцией на одной архитектуре, не может быть на другой. А если такой операции нет, тогда появляется шанс, что пока один поток загрузил часть данных, второй поток прервал выполнение первого и изменил структуру, потом первый вернул управление и считал оставшуюся часть. Но это уже часть изменившейся структуры, а следовательно первый поток содержит некорректные данные!
Дабы извести подобные ситуации, на корню, и были введены атомарные объекты. Атомарный объект – это такой объект операции над которым можно считать неделимыми, т.е. такими, которые не могут быть прерваны или результат которых не может быть получен, до окончания операции. Таким образом исключается сама возможность получения некорректных данных

1. Состояние гонки <br /> 
Состояние гонки - это состояние многопоточной системы, при котором работа системы зависит от того, 
в каком порядке выполняются части кода. Допустим два потока обращаются к одной общей переменной и 
как-либо её модифицируют. Пусть по замыслу разработчика первый поток должен внести изменения в переменную, 
затем второй поток должен считать новое значение переменной и снова как-либо его модифицировать.
При состоянии гонки может случится так, что второй поток прочитает значение переменной раньше, чем 
первый поток успеет его модифицировать, что приведет к непредсказуемому результату <br />

2. Mutex'ы и условные переменные <br />
Mutex является примитивом синхронизации.
Примитивы синхронизации — механизмы, позволяющие реализовать взаимодействие потоков, например, 
единовременный доступ только одного потока к критической области.
Примитивы синхронизации преследуют различные задачи:
- Взаимное исключение потоков — примитивы синхронизации гарантируют то, что единовременно с критической областью будет работать только один поток.
- Синхронизация потоков — примитивы синхронизации помогают отслеживать наступление тех или иных конкретных событий, то есть поток не будет работать, пока не наступило какое-то событие. Другой поток в таком случае должен гарантировать наступление данного события. <br />
Условная переменная - примитив синхронизации, обеспечивающий блокирование одного или нескольких потоков до момента поступления сигнала от другого потока о выполнении некоторого условия или до истечения максимального промежутка времени ожидания. <br />

3. Гранулярность блокировок <br />
Под гранулярность понимается объем данных, защищаемых блокировкой. Гранулярность определяет, к 
каким данным доступ будет заблокирован, а также продолжительность блокировки. если несколько 
потоков ждут одного ресурса , то, удерживая блокировку дольше необходимого, они заставляют 
другие потоки проводить в очереди больше времени. Мьютекс должен захватываться непосредственно перед доступом к разделяемым 
данным; Обработка данных, находящихся под защитой мьютекса, по возможности не должна производится длительными операциями. 
Например файловый ввод/вывод, обычно выполняется в сотни раз медленнее чтения или записи того же объема данных в 
памяти. Поэтому если блокировка не нужна для защиты доступа к файлу, то удерживание блокировки 
заставляет другие потоки ждать без необходимости (так как они не могут захватить мьютекс), и тем 
самым можно свести на нет весь выигрыш от многопоточной работы. Если один мьютекс защищает структуру данных целиком, 
то не только возрастает конкуренция за него, но и шансов снизить время удержания остается меньше. Поскольку под 
защитой одного мьютекса приходится выполнять больше операций, то и удерживать его нужно дольше. Такая двойная угроза 
должна вдвое усилить стремление всюду, где возможно, использовать мелкогранулярные блокировки. <br />

4. Взаимная блокировка <br />
Взаимная блокировка - ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение. Классический способ борьбы с взаимными блокировками состоит в том, чтобы захватывать несколько мьютексов всегда в одинаковом порядке. 
Более строго, это значит, что между блокировками устанавливается отношение сравнения и вводится правило о запрете захвата «большей» блокировки в состоянии, когда уже захвачена «меньшая». Таким образом, если процессу нужно несколько блокировок, ему нужно всегда начинать с самой «большой» — предварительно освободив все захваченные «меньшие», если такие есть — и затем в нисходящем порядке. Это может привести к лишним действиям (если «меньшая» блокировка нужна и уже захвачена, она освобождается только чтобы тут же быть захваченной снова), зато гарантированно решает проблему.

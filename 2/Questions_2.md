1. Так как компьютерный процессор работает строго детерминировано, то возникает задача генерации случайных
чисел. По-настоящему случайные числа называются криптографически стойкими случайными числами, их генерация -
трудозатратный процесс, поэтому используется генераторы псевдослучайных чисел, которые генерируют последовательности
чисел, похожие на случайные. Простейший алгоритм ГПСЧ принимает некое число, называемое зерном, и совершает с ним множество математических
операций, в результате получается последовательность чисел, похожих на случайные. Если каждый раз при запуске
такого алгоритма использовать одно и то же зерно, то генерируемые числа будут те же самые, что и при первом
запуске. Следовательно при каждом запуске генератора необходимо получать уникальное зерно. Например, можно использовать 
текущее время. Ограничить диапозон генерируемых чисел можно посредством деления по остатку и добавления нижней границы
диапозона.<br/>

Библиотека random предоставляет три интсрумента
i) класс std::random_device - этот класс запрашивает у операционной системы случайное целое число и использует его
в качестве зерна
ii) класс std::mt19937 и другие классы псевдо-случайных генераторов, которые используя полученное зерно получают
последовательность чисел
iii) классы распределений, например, линейное распределение, которое возникает, когда вероятность появления каждого из допустимых
чисел одинакова. Есть и другие распределения, например, нормальное

2.

3) Итераторы: <br/>
InputIterator<br/>
Копирование, присваивание.<br/>
Операции сравнения на равенство == и !=.<br/>
Инкремент: ++iter и iter++.<br/>
Разыменование для чтения: *iter и iter->m, при этом запрещена запись: *iter = value;.<br/>

OutputIterator<br/>
Копирование, присваивание.<br/>
Инкремент: ++iter и iter++.<br/>
Разыменование для записи: *iter = value и *iter++ = value, при этом запрещено чтение.<br/>

ForwardIterator (прямой)<br/>
Все операции InputIterator и OutputIterator.<br/>
Требование многопроходности: если i1 == i2, то ++i1 == ++i2, т.е. итератор можно копировать, и обходить им последовательность много раз.<br/>
Прямые итераторы - это итераторы односвязных списков, например std::forward_list.<br/>

BidirectionalIterator (двусторонний)<br/>
Все операции ForwardIterator.<br/>
Декремент: --iter, iter--, *iter--.<br/>

RandomAccessIterator (произвольного доступа)<br/>
Все операции BidirectionalIterator.<br/>
Операции сравнения: i1 < i2, i1 > i2, i1 <= i2, i1 >= i2.<br/>
Сложение/вычитание с числом: iter + n, iter += n, iter - n, iter -= n.<br/>
Разность итераторов: i2 - i1.<br/>
Индексирование: iter[n]<br/>



4. Стандартные алгоритмы делятся на:<br/>

   - Не изменяющие операции — используются для просмотра данных в контейнере, но такие алгоритмы не изменяют содержимое контейнера (например, операции поиска или подсчета элементов).<br/>
   - Изменяющие операции — непосредственно изменяют содержимое контейнера (например, операции перестановки элементов).
   -Операции сортировки
   -Операции поиска
   -Операции слияния (merge, set_union)
   -Кучи (make_heap, pop_heap, push_heap, sort_heap)
   -Операции отношений (min, max)

 
